#define _CRT_SECURE_NO_WARNINGS
#include <string.h>
#include <stdio.h>
#include <math.h>
void print_stu(struct Stu ss);
void set_stu(struct Stu ss);
int  is_leap_year(int y);

struct Stu
{
	char name[20];
	int age;
	double score;
};
int main()
{
// " / "   除法
	// 整形的除法 1/2 ――> 0
	// 浮点型的除法 1.0/2 ――> 0.5
	//			   1/2.0
	//             1.0/2.0

// " % "   取模
	// 两边必须是整数
	printf("%d \n", -5 / 2);


// 整数的二进制有3种
// 原码 反码 补码
// 正的整数 原码、反码、补码相同
// 负的整数 原码、反码、补码需要计算
// 7     ==      00000000 00000000 00000000 00000111  --原码
//               00000000 00000000 00000000 00000111  --反码
//               00000000 00000000 00000000 00000111  --补码
// 
// -7    ==      10000000 00000000 00000000 00000111  --原码
// 	             11111111 11111111 11111111 11111000  --反码  -- 原码的符号位不变，其他位按位取反就是反码
// 	             11111111 11111111 11111111 11111001  --补码  -- 反码加 1 就是补码
// 
//  整数在内存中存储的是补码
// 移位操作符  -- 必须是整数
	// 左移操作符 ―― 移动的是二进制位
	// 左边抛弃、右边补0

	int a = 7;
	int b = -7;
	printf("a << 1 = %d \n", a << 1);
	printf("a = %d \n", a);

	printf("b << 1 = %d \n", b << 1);
	printf("b = %d \n", b);


	// 右移操作符 ―― 移动的是二进制位 
	// 算数移位: 右边丢弃，左边补原符号位  -- vs2022 采用算数右移 
	// 逻辑移位：右边丢弃，左边补0
	printf("a >> 1 = %d \n", a >> 1);
	printf("a = %d \n", a);

	printf("b >> 1 = %d \n", b >> 1);
	printf("b = %d \n", b);

// 位操作符              -- 操作数必须是整数  -- 符号位也要考虑
// & - 按 2 进制位 与
// | - 按 2 进制位 或
// ^ - 按 2 进制位 异或

	int c = 3;
	int d = -5;
	
	// 00000000 00000000 00000011 -- 3的补码
	
	// 10000000 00000000 00000101 -- -5的原码
	// 11111111 11111111 11111010 -- -5的反码
	// 11111111 11111111 11111011 -- -5的补码

	// 按位与
	// 00000000 00000000 00000011 -- 3的补码
	// 11111111 11111111 11111011 -- -5的补码

	// 00000000 00000000 00000011 -- 3 & -5 的按位与 为 3


	printf("c & d = %d\n", c  & d);
	

	// 按位或
	// 00000000 00000000 00000011 -- 3的补码
	// 11111111 11111111 11111011 -- -5的补码

	// 11111111 11111111 11111011 -- 3 & -5 的按位或 为 -5
	printf("c | d = %d\n", c | d);

	
	// 按位异或   --对应的二进制位， 相同为0， 不同为1
	// 00000000 00000000 00000011 -- 3的补码
	// 11111111 11111111 11111011 -- -5的补码

	// 11111111 11111111 11111000 
	// 11111111 11111111 11110111 
	// 10000000 00000000 00001000 -- 3 & -5 的按位异或 为 -8

	printf("c ^ d = %d\n", c ^ d);


// 不创建临时变量，实现两个数的交换
	// a = 7, b = -7

    // 存在潜在的溢出问题
	a = a + b;
	b = a - b;
	a = a - b;
	printf("a = %d\n", a);
	printf("b = %d\n", b); 

	// 3^3 = 0;  a ^ a = 0;相同数字异或为0
	// 0^5 = 5; 0 ^ a = a;
	// 3 ^ 3 ^ 5 = 5;
	// 3 ^ 5 ^ 3 = 5;
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("a = %d\n", a);
	printf("b = %d\n", b);


//  编写代码实现：求一个整数存储在内存中的二进制1的个数
    // 求补码的二进制1的个数
	int e = 6;
	int i = 0;
	int j = 1;
	int count = 0;
	while (i<10)
	{
		if ((e & j) != 0)
		{
			count++;
		}

		j *= 2;
		i += 1;
	}
	printf("count=%d\n", count);

	int flag = 0;
	if (!flag)
	{
		printf("++++++++++\n");
	}
// ~按二进制取反
	int f = 0;
	// 00000000 00000000 00000000 00000000 补码
	// 11111111 11111111 11111111 11111111 ~f   补码
	// 11111111 11111111 11111111 11111110 反码
	// 10000000 00000000 00000000 00000001
	printf("%d\n", ~f);  // -1


	int g = (int) 3.14;
	printf("%d\n", g);
	char arr[5] = { 'c','a','\0'};
	printf("len arr = %u\n", strlen(arr));

	// 两个字符串比较相等应该用strcmp进行比较
	//if ("abc" == "abdefd")  // 这样写是在比较2个字符串的首字符的地址
	//{
	//}

// && 逻辑与  --并且
	int h = 3;
	int k = 5;
	int hk = h && k;  
	printf("hk = %d\n", hk);

// || 逻辑或  --或者

	hk = h || k;
	printf("hk = %d\n", hk);
	
	// 判断闰年，两者满足一个就行 
	// 1、能被4整除，并且不能被100政策
	// 2、能被400整除是闰年

	int y = 2022;
	int judge = is_leap_year(y);

	int l = 3;
	int m = 4;


// 三目操作符
	m = (l > 5 ? 2 : 5);
	printf("m = %d\n", m);

// 逗号表达式 --加括号运行，可避免错误 
	printf("l = %d\n", l);
	l = (m + 1, l + 2);
	printf("l = %d\n", l);
	printf("&a = %p\n", &a);
	char arr2[] = {'a','b', '\0'};
	printf("arr2 = %s\n", arr2);
	printf("arr2[1] = %c\n", arr2[1]);
	printf("1[arr2] = %c\n", 1[arr2]);
	printf("*(arr2+1) = %c\n", *(arr2+1));


	return 0;
}



int is_leap_year(int y)
{
	if (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0))
	{
		return 1;
	}
	else
	{
		return 0;
	}

	
}